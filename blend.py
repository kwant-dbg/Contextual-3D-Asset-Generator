import bpy
import sys
import json
import os

def hex_to_rgba(hex_color):
    """Converts a hex color string to an RGBA tuple."""
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) / 255.0 for i in (0, 2, 4)) + (1.0,)

def setup_scene():
    """Clears the default scene and sets up render settings for transparent PNG."""
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    bpy.context.scene.render.film_transparent = True
    bpy.context.scene.render.image_settings.color_mode = 'RGBA'
    bpy.context.scene.render.image_settings.file_format = 'PNG'

def create_generative_material(name, colors):
    """
    SIMULATED: Creates a material simulating a generative texture.
    In a real system, this would load a texture from a StyleGAN.
    Here, we create a procedural noise texture using the provided color palette.
    """
    mat = bpy.data.materials.new(name=name)
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    bsdf = nodes.get('Principled BSDF')
    
    # Create a color ramp to map noise values to our palette
    color_ramp = nodes.new(type='ShaderNodeValToRGB')
    color_ramp.color_ramp.elements.remove(color_ramp.color_ramp.elements[0]) # remove default black
    
    # Distribute colors along the ramp
    num_colors = len(colors)
    for i, color_hex in enumerate(colors):
        element = color_ramp.color_ramp.elements.new(position=i / (num_colors - 1 if num_colors > 1 else 1))
        element.color = hex_to_rgba(color_hex)
        
    # Create a noise texture to drive the color ramp
    noise_tex = nodes.new(type='ShaderNodeTexNoise')
    noise_tex.inputs['Scale'].default_value = 10.0
    noise_tex.inputs['Detail'].default_value = 8.0
    noise_tex.inputs['Roughness'].default_value = 0.6
    
    # Link nodes: Noise Texture -> Color Ramp -> BSDF Base Color
    mat.node_tree.links.new(noise_tex.outputs['Fac'], color_ramp.inputs['Fac'])
    mat.node_tree.links.new(color_ramp.outputs['Color'], bsdf.inputs['Base Color'])
    
    return mat

def main():
    """Main execution function for the Blender script."""
    try:
        # Get JSON parameters passed from the command line
        argv = sys.argv
        args_str = argv[argv.index("--") + 1]
        params = json.loads(args_str)
    except (ValueError, IndexError):
        print("Error: No valid JSON parameters provided.")
        sys.exit(1)

    setup_scene()

    # --- Step 1: Load the shape generated by a (simulated) 3D GAN ---
    try:
        bpy.ops.import_scene.obj(filepath=params['shape_asset_path'])
        obj = bpy.context.selected_objects[0]
        bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')
        obj.location = (0, 0, 0) # Center the object
    except Exception as e:
        print(f"Error loading OBJ file: {e}")
        sys.exit(1)
    
    # --- Step 2: Apply the texture from a (simulated) Texture GAN ---
    material = create_generative_material("GeneratedTexture", params['colors'])
    if obj.data.materials:
        obj.data.materials[0] = material
    else:
        obj.data.materials.append(material)

    # --- Step 3: Setup basic lighting and camera ---
    bpy.ops.object.light_add(type='SUN', align='WORLD', location=(0, -5, 5), rotation=(0.785, 0, -0.785))
    bpy.context.object.data.energy = 3.0 # Make it brighter

    bpy.ops.object.camera_add(location=(0, -3.5, 2.5))
    camera = bpy.context.object
    bpy.context.scene.camera = camera
    
    # Point camera at the object
    look_at_constraint = camera.constraints.new(type='TRACK_TO')
    look_at_constraint.target = obj
    look_at_constraint.track_axis = 'TRACK_NEGATIVE_Z'
    look_at_constraint.up_axis = 'UP_Y'

    # --- Step 4: Render the final image and save it ---
    bpy.context.scene.render.filepath = os.path.abspath(params['output_path'])
    bpy.ops.render.render(write_still=True)
    print(f"Rendered image saved to {params['output_path']}")

if __name__ == "__main__":
    main()

