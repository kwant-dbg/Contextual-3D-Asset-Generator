# -*- coding: utf-8 -*-
"""
Blender Rendering Script for Contextual 3D Asset Generator

This script is executed by the Flask backend to perform the following tasks:
1.  Set up a clean Blender scene.
2.  Import a 3D model (simulating the output of a generative model).
3.  Create and apply a procedural material (simulating a generative texture).
4.  Set up lighting and a camera.
5.  Render the object with a transparent background and save it as a PNG.

This script is designed to be run in Blender's background mode.
"""

import bpy
import sys
import json
import os

# --- Utility Functions ---

def hex_to_rgba(hex_color):
    """
    Converts a hex color string (e.g., "#RRGGBB") to a Blender-compatible
    RGBA tuple (values from 0.0 to 1.0).
    """
    hex_color = hex_color.lstrip('#')
    # Unpack hex values and normalize to the 0-1 range
    return tuple(int(hex_color[i:i+2], 16) / 255.0 for i in (0, 2, 4)) + (1.0,) # Alpha is always 1.0

def setup_scene():
    """
    Prepares the Blender scene for rendering.
    - Deletes all existing objects.
    - Configures render settings for transparent PNG output.
    """
    # Select and delete all objects in the scene
    if bpy.context.object:
        bpy.ops.object.select_all(action='SELECT')
        bpy.ops.object.delete()

    # Set render engine to Cycles for better quality, or Eevee for speed
    bpy.context.scene.render.engine = 'CYCLES'
    # Make the background transparent
    bpy.context.scene.render.film_transparent = True
    # Set output format to PNG with RGBA channels
    bpy.context.scene.render.image_settings.color_mode = 'RGBA'
    bpy.context.scene.render.image_settings.file_format = 'PNG'
    # Set resolution
    bpy.context.scene.render.resolution_x = 1024
    bpy.context.scene.render.resolution_y = 1024

def create_generative_material(name, colors):
    """
    SIMULATED: Creates a procedural material to simulate a generative texture.
    
    In a real system, this function would load an image texture generated by a
    model like StyleGAN. Here, we use Blender's node system to create a
    procedural noise texture that uses the provided color palette.
    
    Args:
        name (str): The name for the new material.
        colors (list): A list of hex color strings for the palette.
        
    Returns:
        bpy.types.Material: The newly created Blender material.
    """
    mat = bpy.data.materials.new(name=name)
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    bsdf = nodes.get('Principled BSDF')
    
    # Clear default nodes
    nodes.clear()
    
    # Re-create the output and BSDF nodes
    output_node = nodes.new(type='ShaderNodeOutputMaterial')
    bsdf_node = nodes.new(type='ShaderNodeBsdfPrincipled')
    bsdf_node.inputs['Roughness'].default_value = 0.7
    bsdf_node.inputs['Specular'].default_value = 0.2
    
    # Link BSDF to output
    mat.node_tree.links.new(bsdf_node.outputs['BSDF'], output_node.inputs['Surface'])
    
    # Create a color ramp to map noise values to our color palette
    color_ramp = nodes.new(type='ShaderNodeValToRGB')
    
    # Remove the default black/white stops
    if len(color_ramp.color_ramp.elements) > 0:
        color_ramp.color_ramp.elements.remove(color_ramp.color_ramp.elements[0])
    if len(color_ramp.color_ramp.elements) > 0:
        color_ramp.color_ramp.elements.remove(color_ramp.color_ramp.elements[0])
        
    # Distribute the provided colors along the ramp
    num_colors = len(colors)
    for i, color_hex in enumerate(colors):
        position = i / (num_colors - 1 if num_colors > 1 else 1)
        element = color_ramp.color_ramp.elements.new(position=position)
        element.color = hex_to_rgba(color_hex)
        
    # Create a noise texture to drive the color ramp, giving a procedural pattern
    noise_tex = nodes.new(type='ShaderNodeTexNoise')
    noise_tex.inputs['Scale'].default_value = 10.0
    noise_tex.inputs['Detail'].default_value = 8.0
    noise_tex.inputs['Roughness'].default_value = 0.6
    
    # Link nodes: Noise Texture -> Color Ramp -> BSDF Base Color
    mat.node_tree.links.new(noise_tex.outputs['Fac'], color_ramp.inputs['Fac'])
    mat.node_tree.links.new(color_ramp.outputs['Color'], bsdf_node.inputs['Base Color'])
    
    return mat

def main():
    """Main execution function for the Blender script."""
    try:
        # Blender scripts are passed arguments after '--'
        argv = sys.argv
        args_str = argv[argv.index("--") + 1]
        params = json.loads(args_str)
    except (ValueError, IndexError):
        print("Error: Script requires JSON parameters passed after '--'.")
        sys.exit(1)

    setup_scene()

    # --- Step 1: Load the 3D model ---
    try:
        bpy.ops.import_scene.obj(filepath=params['shape_asset_path'])
        # The imported object is automatically selected
        obj = bpy.context.selected_objects[0]
        # Center the object's origin for predictable rotation and scaling
        bpy.ops.object.origin_set(type='ORIGIN_GEOMETRY', center='BOUNDS')
        obj.location = (0, 0, 0)
    except Exception as e:
        print(f"Error: Failed to load OBJ file at '{params['shape_asset_path']}'. Details: {e}")
        sys.exit(1)
    
    # --- Step 2: Create and apply the material ---
    material = create_generative_material("GeneratedTexture", params.get('colors', ["#808080"]))
    if obj.data.materials:
        # Replace the existing material
        obj.data.materials[0] = material
    else:
        # Add the material if there are no slots
        obj.data.materials.append(material)

    # --- Step 3: Set up lighting and camera ---
    # Add a sun light for strong, directional lighting
    bpy.ops.object.light_add(type='SUN', align='WORLD', location=(0, -5, 5), rotation=(0.785, 0, -0.785))
    bpy.context.object.data.energy = 3.0

    # Add a camera and position it
    bpy.ops.object.camera_add(location=(0, -3.5, 2.5))
    camera = bpy.context.object
    bpy.context.scene.camera = camera
    
    # Use a 'Track To' constraint to make the camera always point at the object
    look_at_constraint = camera.constraints.new(type='TRACK_TO')
    look_at_constraint.target = obj
    look_at_constraint.track_axis = 'TRACK_NEGATIVE_Z'
    look_at_constraint.up_axis = 'UP_Y'

    # --- Step 4: Render and save the image ---
    output_path = os.path.abspath(params['output_path'])
    bpy.context.scene.render.filepath = output_path
    bpy.ops.render.render(write_still=True)
    
    print(f"Success: Rendered image saved to {output_path}")

if __name__ == "__main__":
    main()

